---
title: Pythagorean Triples
description: "The hidden patterns of right integer triangles"
author: Edward Visel
date: '2018-03-23'
slug: pythagorean-triples
featured: "triples.png"
featuredalt: "Pythagorean triples"
featuredpath: "date"
type: post
categories:
  - R
  - dataviz
tags:
  - dataviz
  - math
  - geometry
---



<p>In a quiet moment, I happened across <a href="https://projecteuler.net/">Project Euler</a>’s
<a href="https://projecteuler.net/problem=39">Question 39</a>:</p>
<blockquote>
<h3 id="integer-right-triangles">Integer right triangles</h3>
<h4 id="problem-39">Problem 39</h4>
<p>If <span class="math inline">\(p\)</span> is the perimeter of a right angle triangle with integral length sides,
<span class="math inline">\(\{a,b,c\}\)</span>, there are exactly three solutions for <span class="math inline">\(p = 120\)</span>:</p>
<p><span class="math display">\[\{20,48,52\}, \{24,45,51\}, \{30,40,50\}\]</span></p>
<p>For which value of <span class="math inline">\(p \le 1000\)</span>, is the number of solutions maximised?</p>
</blockquote>
<p>Put another way, what integer perimeter less than or equal to 1000 has the most
<a href="https://en.wikipedia.org/wiki/Pythagorean_triple">Pythagorean triples</a>?</p>
<p>While Wikipedia reveals there exist ways of generating triples directly like
Euclid’s Formula, I find approaching Project Euler questions with the math I
remember is decidedly more rewarding than simply implementing someone else’s
solution, so I deliberately avoided searching for solutions, and got to coding.</p>
<p>The simplest possible solution would be some variation of iterating over
integers the shorter leg <span class="math inline">\(a\)</span> and longer leg <span class="math inline">\(b\)</span> and checking if the hypotenuse
<span class="math inline">\(c\)</span> generated by the Pythagorean theorem <span class="math inline">\(c = \sqrt{a^2 + b^2}\)</span> is an integer.
In the course of implementing such an approach, some optimizations become
obvious:</p>
<ul>
<li><p>What are possible values for <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> to iterate over? Since the smallest
triple is <span class="math inline">\(\{3, 4, 5\}\)</span> and <span class="math inline">\(a &lt; b &lt; c\)</span> (since the hypotenuse is longer than
the legs and if <span class="math inline">\(a = b\)</span> the triangle would be a 45-45-90 with <span class="math inline">\(c = a\sqrt{2}\)</span>),</p>
<ul>
<li><span class="math inline">\(a\)</span> must be less than <span class="math inline">\(\frac{1}{3}P\)</span> where <span class="math inline">\(P\)</span> is the perimeter. Given the
<span class="math inline">\(\{3, 4, 5\}\)</span> and the question, <span class="math inline">\(12 \le P \le 1000\)</span>, so <span class="math inline">\(1 \le a \le 333\)</span>.
The domain can actually be whittled further, but removing <span class="math inline">\(\frac{2}{3}\)</span> of
the cases is a solid start.</li>
<li>Similarly, since <span class="math inline">\(b &lt; c\)</span>, <span class="math inline">\(b\)</span> makes up less than half of the perimeter,
so <span class="math inline">\(2 \le b \le 499\)</span>.</li>
</ul></li>
<li><p>More broadly, is iterating over <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> efficient, given the question is
about perimeters? A more direct solution would be to iterate over <span class="math inline">\(P\)</span> values.
Each perimeter may have multiple triples, so nested iteration would still be
necessary. But given <span class="math inline">\(P\)</span>, is one more parameter, e.g. <span class="math inline">\(c\)</span>, sufficient?</p></li>
</ul>
<p>This last proposition seemed likely, and led me to explore on
<a href="http://desmos.com/">Desmos</a>:</p>
<iframe src="https://www.desmos.com/calculator/8pnqq7pl4o?embed" width="500px" height="500px" style="border: 1px solid #ccc" frameborder="0">
</iframe>
<p>In this graph, <span class="math inline">\(x = a\)</span>, <span class="math inline">\(y = b\)</span>, <span class="math inline">\(c\)</span> is parameterized as <span class="math inline">\(z\)</span> (here iterating
over integers from <span class="math inline">\(ceiling(\sqrt{2} - 1) * P\)</span>—a right isosceles triangle—
to <span class="math inline">\(\frac{P}{2}\)</span>—a flat line), and the perimeter is another parameter <span class="math inline">\(P\)</span> (here
fixed at 120).</p>
<ul>
<li>The circle is the points for which the Pythagorean theorem holds,
i.e. <span class="math inline">\(x^2 + y^2 = z^2\)</span>, i.e. right triangles.</li>
<li>The black line is defined by <span class="math inline">\(P = a + b + c\)</span>, rearranged here
as <span class="math inline">\(y = P - x - z\)</span>. As <span class="math inline">\(P\)</span> and <span class="math inline">\(z\)</span> are parameters that are fixed for any
given value (here, frame), this equation therefore takes the form of a line
with a slope of -1 and a y-intercept of <span class="math inline">\(P - z\)</span>.</li>
<li>The violet area is defined by <span class="math inline">\(0 &lt; x &lt; y\)</span>, i.e. the only place solutions will
exist.</li>
</ul>
<p>Therefore, the intersection of the circle and the line within the violet region
is the single right triangle for <span class="math inline">\(P = 120\)</span> and the given <span class="math inline">\(z\)</span> value. Obviously
now, there is a single triangle for each perimeter and hypotenuse, though it
is only a triple if all values are integers.</p>
<p>The graph also suggests how to solve for <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> for a given <span class="math inline">\(P\)</span> and <span class="math inline">\(c\)</span>:
solve the system of equations created by the perimeter and Pythagorean theorem
for <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span>. Since <span class="math inline">\(P\)</span> and <span class="math inline">\(c\)</span> are constants, if solved for <span class="math inline">\(a\)</span>, then <span class="math inline">\(b\)</span> is
simply <span class="math inline">\(b = P - c - a\)</span>. Rearranging and substituting,</p>
<p><span class="math display">\[b = P - c - a = (P - c) - a\]</span>
<span class="math display">\[a^2 + ((P - c) - a)^2 = c^2\]</span>
In terms of <span class="math inline">\(a\)</span>, this equation is a quadratic, so rearranging into standard form,</p>
<p><span class="math display">\[a^2 + (P - c)^2 + a^2 + 2(P - c)a = c^2\]</span>
<span class="math display">\[2a^2 + 2(P - c)a + P^2 + 2Pc + c^2 = c^2\]</span>
<span class="math display">\[2a^2 - 2(P - c)a + P(P - 2c)= 0\]</span>
While not exactly elegant, this is a quadratic where <span class="math inline">\(A = 2\)</span>, <span class="math inline">\(B = -2(P - c)\)</span>
and <span class="math inline">\(C = P(P - 2c)\)</span>, and thus can be solved for <span class="math inline">\(a\)</span> using the quadratic formula:</p>
<p><span class="math display">\[a = \frac{2(P - c) \pm \sqrt{(-2(P - c))^2 - 4*2*P(P - 2c)}}{2 * 2}\]</span>
<span class="math display">\[a = \frac{P - c \pm \sqrt{P^2 - 2Pc + c^2 - (2P^2 - 4Pc)}}{2}\]</span>
<span class="math display">\[a = \frac{P - c \pm \sqrt{c^2 + 2Pc - P^2}}{2}\]</span></p>
<p>In fact, this equation shows how to solve for both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>; <span class="math inline">\(a\)</span> will be the
result of subtracting the discriminant, <span class="math inline">\(b\)</span> adding (though subtracting from <span class="math inline">\(P\)</span>
is still simpler).</p>
<p>Best of all, coded in R, this equation is nicely vectorized across <span class="math inline">\(c\)</span>, so</p>
<pre class="r"><code>legs &lt;- function(P, c){
    discriminant &lt;- sqrt(c^2 + 2*P*c - P^2)
    a &lt;- (P - c - discriminant) / 2
    b &lt;- P - c - a
    data.frame(a, b, c, P)
}

triples &lt;- legs(120, 50:59)
triples
#&gt;            a        b  c   P
#&gt; 1  30.000000 40.00000 50 120
#&gt; 2  24.000000 45.00000 51 120
#&gt; 3  20.000000 48.00000 52 120
#&gt; 4  16.699702 50.30030 53 120
#&gt; 5  13.790627 52.20937 54 120
#&gt; 6  11.139991 53.86001 55 120
#&gt; 7   8.676192 55.32381 56 120
#&gt; 8   6.355418 56.64458 57 120
#&gt; 9   4.148557 57.85144 58 120
#&gt; 10  2.035109 58.96489 59 120</code></pre>
<p>Within this result are the three triples: <span class="math inline">\(\{30,40,50\}\)</span>, <span class="math inline">\(\{24,45,51\}\)</span> and
<span class="math inline">\(\{20,48,52\}\)</span>, which can be separated by checking <code>a %% 1 == 0</code>:</p>
<pre class="r"><code>triples[triples$a %% 1 == 0, ]
#&gt;    a  b  c   P
#&gt; 1 30 40 50 120
#&gt; 2 24 45 51 120
#&gt; 3 20 48 52 120</code></pre>
<p>With this foundation, to generate triples for all <span class="math inline">\(P \le 1000\)</span> just requires
iterating over <span class="math inline">\(P\)</span>. Optimized a bit and using <code>purrr::map_dfr</code> to collapse the
results,</p>
<pre class="r"><code>triples &lt;- purrr::map_df(12:1000, function(P){
    c &lt;- seq.int(from = ceiling((sqrt(2) - 1) * P),    # 45-45-90
                 to = floor((P - 1) / 2),    # flat
                 by = 1L)
    discriminant &lt;- sqrt(c^2 + 2*P*c - P^2)
    a &lt;- (P - c - discriminant) / 2
    is_triple &lt;- a %% 1 == 0
    if (any(is_triple)) {
        a &lt;- a[is_triple]
        c &lt;- c[is_triple]
        b &lt;- P - c - a
        list(P = rep(P, length(a)), 
             a = a, 
             b = b, 
             c = c)
    } else NULL
})

triples
#&gt; # A tibble: 325 x 4
#&gt;        P     a     b     c
#&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt;  1    12    3.    4.    5.
#&gt;  2    24    6.    8.   10.
#&gt;  3    30    5.   12.   13.
#&gt;  4    36    9.   12.   15.
#&gt;  5    40    8.   15.   17.
#&gt;  6    48   12.   16.   20.
#&gt;  7    56    7.   24.   25.
#&gt;  8    60   15.   20.   25.
#&gt;  9    60   10.   24.   26.
#&gt; 10    70   20.   21.   29.
#&gt; # ... with 315 more rows</code></pre>
<p>Beautiful. Answering the question from here is trivial, but more usefully, this
approach has produced a lovely dataset to explore, and can easily produce an
extended version by simply scaling to a bigger range of <span class="math inline">\(P\)</span> values:</p>
<pre class="r"><code>triples &lt;- purrr::map_df(12:50000, function(P){
    c &lt;- seq.int(from = ceiling((sqrt(2) - 1) * P),    # 45-45-90
                 to = floor((P - 1) / 2),    # flat
                 by = 1L)
    discriminant &lt;- sqrt(c^2 + 2*P*c - P^2)
    a &lt;- (P - c - discriminant) / 2
    is_triple &lt;- a %% 1 == 0
    if (any(is_triple)) {
        a &lt;- a[is_triple]
        c &lt;- c[is_triple]
        b &lt;- P - c - a
        list(P = rep(P, length(a)), 
             a = a, 
             b = b, 
             c = c)
    } else NULL
})

triples
#&gt; # A tibble: 29,933 x 4
#&gt;        P     a     b     c
#&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt;  1    12    3.    4.    5.
#&gt;  2    24    6.    8.   10.
#&gt;  3    30    5.   12.   13.
#&gt;  4    36    9.   12.   15.
#&gt;  5    40    8.   15.   17.
#&gt;  6    48   12.   16.   20.
#&gt;  7    56    7.   24.   25.
#&gt;  8    60   15.   20.   25.
#&gt;  9    60   10.   24.   26.
#&gt; 10    70   20.   21.   29.
#&gt; # ... with 29,923 more rows</code></pre>
<p>Lovely. Let’s explore. After making a lot of plots, I found I mostly just
wanted to try different aesthetics, so I wrote a function, coloring points by
the parity of <span class="math inline">\(a\)</span> to show some differentiation:</p>
<pre class="r"><code>library(tidyverse)
#&gt; ── Attaching packages ───────────────────────────────────────────────────────────── tidyverse 1.2.1 ──
#&gt; ✔ ggplot2 2.2.1.9000     ✔ purrr   0.2.4     
#&gt; ✔ tibble  1.4.2          ✔ dplyr   0.7.4     
#&gt; ✔ tidyr   0.8.0          ✔ stringr 1.3.0     
#&gt; ✔ readr   1.2.0          ✔ forcats 0.3.0
#&gt; ── Conflicts ──────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
#&gt; ✖ dplyr::filter() masks stats::filter()
#&gt; ✖ dplyr::lag()    masks stats::lag()

plot_triples &lt;- function(aes, 
                         ylab = rlang::quo_name(aes$y), 
                         max_c = 20500){
    triples %&gt;% 
        filter(c &lt; max_c) %&gt;%    # subset if desired
        mutate(a_parity = ifelse(a %% 2 == 0, &#39;even&#39;, &#39;odd&#39;)) %&gt;% 
        ggplot(aes) + 
        geom_point(size = 0.5, alpha = 0.5) + 
        scale_x_continuous(labels = scales::comma_format(), expand = c(0, 0)) + 
        scale_y_continuous(labels = scales::comma_format(), expand = c(0, 0)) + 
        # prettify
        ggsci::scale_color_d3(
            guide = guide_legend(override.aes = list(alpha = 1))) + 
        labs(title = &#39;Pythagorean Triples&#39;, 
             y = ylab, 
             color = expression(Parity~of~italic(a))) + 
        hrbrthemes::theme_ipsum_rc(plot_margin = margin(10, 10, 5, 10), 
                                   grid = FALSE) + 
        theme(legend.position = &#39;bottom&#39;, 
              legend.direction = &#39;horizontal&#39;, 
              legend.key.size = unit(10, &#39;pt&#39;),
              legend.justification = 0.01,
              legend.margin = margin(0, 0, 0, 0),
              axis.title.y = element_text(angle = 0))
}</code></pre>
<p>Iterating plots is now quite quick. First, the relationship between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>,
i.e. is the triangle long and skinny or near isosceles?</p>
<pre class="r"><code>plot_triples(aes(b, a, color = a_parity, max_c = Inf))</code></pre>
<p><img src="/blog/2018-03-23-pythagorean-triples_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<pre class="r"><code>plot_triples(aes(b, a, color = a_parity))</code></pre>
<p><img src="/blog/2018-03-23-pythagorean-triples_files/figure-html/unnamed-chunk-6-2.png" width="672" /></p>
<p>A few features are immediately apparent. Subsetting data by <span class="math inline">\(P\)</span> (as
it was generated) returns a triangle, which makes sense—if <span class="math inline">\(a\)</span> is very small,
<span class="math inline">\(b\)</span> can claim more of the maximum perimeter, whereas if <span class="math inline">\(a\)</span> is very large, the
biggest <span class="math inline">\(b\)</span> can be is a tiny bit larger. The tradeoff is linear, producing the
upper-right leg of the triangle.</p>
<p>Subsetting by <span class="math inline">\(c\)</span> instead turns the triangle into a sector of a circle. Taking
the Pythagorean theorem as the equation of a circle, the shape makes sense.
Unlimited, the graph would continue to the right.</p>
<p>The upper left leg or radius of the output space is the line <span class="math inline">\(y = x\)</span>, as <span class="math inline">\(a\)</span> is
defined as less than <span class="math inline">\(b\)</span>. If <span class="math inline">\(b\)</span> were allowed to be larger than <span class="math inline">\(a\)</span> (i.e. if
the dataset were doubled by flipping <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>), this space would continues
not only to the right, but also upwards through the rest of the first quadrant.
Relaxing the assumption that <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are positive would extend the space
into all four quadrants. All non-plotted areas would be reflections of the
current points.</p>
<p>More interesting than the output space are the patterns visible within the points.
Most evident are the rays shooting out from the origin, which are explained by
multiples: since <span class="math inline">\(\{3, 4, 5\}\)</span> is a triple, <span class="math inline">\(\{6, 8, 10\}\)</span>, <span class="math inline">\(\{30, 40, 50\}\)</span>,
etc. will be too. The densest rays are products of the smallest initial triples;
spottier rays are products of larger initial triples that therefore recur less.</p>
<p>There are also some curvilinear patterns within the points. These are less
simple to explain, <a href="https://en.wikipedia.org/wiki/Pythagorean_triple#Distribution_of_triples">but have been</a>.
They are parabolas centered along each axis with foci at the origin.</p>
<p>Let’s get some different views.</p>
<pre class="r"><code>plot_triples(aes(c, a, color = a_parity))</code></pre>
<p><img src="/blog/2018-03-23-pythagorean-triples_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>Plotting <span class="math inline">\(a\)</span> as a function of <span class="math inline">\(c\)</span> instead of <span class="math inline">\(b\)</span>, the rays remain, but the
parabolas change. The concavity of one set has flipped, and the other has
turned into diagonal lines.</p>
<p>Curious. Let’s rearrange.</p>
<pre class="r"><code>plot_triples(aes(c, a/c, color = a_parity), 
             ylab = expression(over(a, c)))</code></pre>
<p><img src="/blog/2018-03-23-pythagorean-triples_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>This is the same as the plot above, but with <span class="math inline">\(a\)</span> rescaled by <span class="math inline">\(c\)</span> so as to spread
the rays converging at the origin across the y-axis. The multiples are now more
easily identifiable: for <span class="math inline">\(\{3, 4, 5\}\)</span>, <span class="math inline">\(\frac{a}{c}=\frac{3}{5}=0.6\)</span>.</p>
<p>The diagonal lines have been turned into hyperbolas à la <span class="math inline">\(y = \frac{1}{x}\)</span> now,
which is a sensible result of dividing by the x variable.</p>
<p>Another exciting effect is the empty space by where each multiple line meets
y-axis. It is explicable: to get a triple with a <span class="math inline">\(\frac{a}{c}\)</span> ratio close to
0.6 without using a multiple of <span class="math inline">\(\frac{3}{5}\)</span> requires a reasonably large
denominator. Harder to explain is the continued rarefaction of the space
further across the graph, particularly visible for the 0.6 line.</p>
<p>Find another pattern? Let me know!</p>
